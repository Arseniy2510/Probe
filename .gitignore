import sys
import math

# Установим порог для сравнения чисел с плавающей точкой
EPSILON = 1e-9

def solve_optimized():
    """
    Решение задачи с оптимизированной сложностью O(n log n).
    """
    # Увеличиваем лимит рекурсии/стека для работы с большими N
    sys.setrecursionlimit(2000) 
    
    # --- 1. Чтение и подготовка данных ---
    try:
        input_data = sys.stdin.read().split()
        if not input_data:
            return
        
        n = int(input_data[0])
        d = float(input_data[1])
        
        T_A_raw = [float(x) for x in input_data[2:2 + n]]
        T_B_raw = [float(x) for x in input_data[2 + n:2 + 2 * n]]
        
    except Exception:
        # В случае ошибок ввода
        return

    # Сортируем времена старта для быстрого поиска ближайшего оппонента
    # Оптимизация: ближайший по t_O - это всегда следующий в отсортированном списке.
    T_A_raw.sort()
    T_B_raw.sort()
    
    # --- 2. Инициализация ---
    
    # Индексы для следующего неиспользованного оппонента в отсортированных списках
    # T_A_idx - для лыжника команды A (нечетного)
    # T_B_idx - для лыжника команды B (четного)
    T_A_idx = 1  # Лыжник 1 (t_1) уже стартует с флагом.
    T_B_idx = 0
    
    # Лыжник 1 (первый в T_A_raw) начинает с флагом
    start_time = T_A_raw[0]
    start_pos = 0.0        
    total_distance = 0.0
    
    # 1: A несет, 0: B несет
    current_carrier_is_A = True 

    # --- 3. Основной цикл моделирования ---
    
    while True:
        
        # 3.1. Определение оппонента
        
        # Индекс в raw-списке, соответствующий следующему оппоненту
        opponent_list = T_B_raw if current_carrier_is_A else T_A_raw
        opponent_idx_ptr = T_B_idx if current_carrier_is_A else T_A_idx
        
        # Проверка на наличие оппонентов
        if opponent_idx_ptr >= len(opponent_list):
            next_runner_t_o = float('inf')
        else:
            next_runner_t_o = opponent_list[opponent_idx_ptr]
            
        # 3.2. Расчет времени доставки (финиша)
        
        if current_carrier_is_A:
            # Движение к d (B)
            time_to_delivery = d - start_pos
            delivery_time = start_time + time_to_delivery
            # Формула для t_meet (C из A, O из B):
            # t_meet = (d + t_o + start_time - start_pos) / 2.0
            t_meet_calc_term = d + start_time - start_pos
        else:
            # Движение к 0 (A)
            time_to_delivery = start_pos - 0.0
            delivery_time = start_time + time_to_delivery
            # Формула для t_meet (C из B, O из A):
            # t_meet = (start_pos + start_time + t_o) / 2.0
            t_meet_calc_term = start_pos + start_time
        
        # 3.3. Расчет встречи с ближайшим оппонентом
        
        t_meet = float('inf')
        
        if next_runner_t_o != float('inf'):
            if current_carrier_is_A:
                t_meet = (t_meet_calc_term + next_runner_t_o) / 2.0
            else:
                t_meet = (t_meet_calc_term + next_runner_t_o) / 2.0

        # 3.4. Принятие решения: Встреча, Доставка или Победа
        
        # Проверка, что встреча произойдет до доставки
        is_meeting_before_delivery = (t_meet < delivery_time - EPSILON)
        
        # Проверка, что оппонент успеет стартовать до встречи
        is_opponent_started_in_time = (t_meet >= next_runner_t_o - EPSILON)

        if is_meeting_before_delivery and is_opponent_started_in_time:
            # Событие: Встреча и передача флага
            
            # Расчет x_meet
            if current_carrier_is_A:
                x_meet = start_pos + (t_meet - start_time)
            else:
                x_meet = start_pos - (t_meet - start_time)
                
            distance_travelled = t_meet - start_time
            total_distance += distance_travelled
            
            # Обновление состояния
            start_time = t_meet
            start_pos = x_meet
            
            # Переключение команды
            if current_carrier_is_A:
                T_B_idx += 1  # Оппонент B использован
            else:
                T_A_idx += 1  # Оппонент A использован
                
            current_carrier_is_A = not current_carrier_is_A
            
        else:
            # Событие: Доставка флага (Победа)
            
            distance_travelled = delivery_time - start_time
            total_distance += distance_travelled
            break
            
    # --- 4. Вывод результата ---
    
    # Ответ должен быть целым числом.
    print(f"{round(total_distance)}")

if __name__ == "__main__":
    solve_optimized()
