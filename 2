import math
import sys

# Установим порог для сравнения чисел с плавающей точкой
EPSILON = 1e-9

def solve():
    """
    Моделирует эстафету, чтобы найти общее расстояние,
    пройденное флагом.
    """
    
    # --- 1. Чтение входных данных ---
    
    # Читаем n (количество лыжников в команде)
    try:
        # Для удобства чтения больших объемов данных
        input_data = sys.stdin.read().split()
        if not input_data:
            return
        
        n = int(input_data[0])
        d = float(input_data[1])
        
        # Считываем времена старта T_A и T_B
        T_A_raw = [float(x) for x in input_data[2:2 + n]]
        T_B_raw = [float(x) for x in input_data[2 + n:2 + 2 * n]]
        
    except Exception:
        # Обработка пустого или неверного ввода
        return

    # Создание словаря времен старта {runner_idx: start_time}
    # Индексация лыжников с 1 до 2*n
    T = {}
    for i in range(n):
        # Лыжники A (нечетные): 1, 3, 5, ...
        T[2 * i + 1] = T_A_raw[i]
        # Лыжники B (четные): 2, 4, 6, ...
        T[2 * i + 2] = T_B_raw[i]

    # --- 2. Инициализация моделирования ---
    
    current_runner_idx = 1
    # Время, когда текущий лыжник начал движение с флагом
    start_time = T.get(1, 0.0) 
    # Позиция, с которой он начал (0.0 для A, d для B)
    start_pos = 0.0        
    total_distance = 0.0
    # Множество лыжников, которые уже несли флаг.
    carried_flag = {1}
    
    # --- 3. Основной цикл моделирования ---
    
    while True:
        is_A = (current_runner_idx % 2 != 0) # Текущий лыжник из A?
        
        # 3.1. Расчет времени и позиции доставки (если нет встреч)
        if is_A:
            # Движение к d (B)
            time_to_delivery = d - start_pos
            delivery_pos = d
            opponent_start_idx = 2  # Оппонент из B (четный)
        else:
            # Движение к 0 (A)
            time_to_delivery = start_pos - 0.0
            delivery_pos = 0.0
            opponent_start_idx = 1  # Оппонент из A (нечетный)

        delivery_time = start_time + time_to_delivery

        min_meeting_time = delivery_time
        next_runner_idx = 0
        meeting_pos = delivery_pos

        # 3.2. Поиск ближайшей встречи с потенциальными оппонентами
        for i in range(opponent_start_idx, 2 * n + 1, 2):
            if i in carried_flag:
                continue
            
            t_o = T.get(i) # Время старта лыжника O
            if t_o is None:
                continue

            # Расчет встречи C (start_pos, start_time) и O (t_o)
            t_meet = -1.0
            x_meet = -1.0
            
            if is_A:
                # C (A->B, +1), O (B->A, -1)
                # 2*t = d + t_o + start_time - start_pos
                t_meet = (d + t_o + start_time - start_pos) / 2.0
                x_meet = start_pos + (t_meet - start_time)
            else:
                # C (B->A, -1), O (A->B, +1)
                # 2*t = start_pos + start_time + t_o
                t_meet = (start_pos + start_time + t_o) / 2.0
                x_meet = start_pos - (t_meet - start_time)

            # Проверка условий встречи:
            # 1. Встреча раньше доставки: t_meet < min_meeting_time
            # 2. Оппонент успел стартовать: t_meet >= t_o
            # 3. Позиция встречи в пределах трассы: 0.0 <= x_meet <= d
            
            if (t_meet < min_meeting_time - EPSILON and 
                t_meet >= t_o - EPSILON):
                
                # Дополнительная проверка на позицию (должна быть избыточной, если t_meet < delivery_time)
                if x_meet >= 0.0 - EPSILON and x_meet <= d + EPSILON:
                    min_meeting_time = t_meet
                    next_runner_idx = i
                    meeting_pos = x_meet

        # 3.3. Принятие решения: Встреча или Доставка
        
        if next_runner_idx != 0:
            # Событие: Встреча и передача флага
            distance_travelled = abs(min_meeting_time - start_time)
            total_distance += distance_travelled
            
            # Обновление состояния для следующего этапа
            start_time = min_meeting_time
            start_pos = meeting_pos
            current_runner_idx = next_runner_idx
            carried_flag.add(next_runner_idx)
        else:
            # Событие: Доставка флага (Победа)
            # Условие задачи: "если флаг принесут в один из пунктов в тот момент,
            # когда из этого пункта стартует очередной лыжник, — это считается победой"
            # Поскольку delivery_time <= min_meeting_time (или min_meeting_time не найдено),
            # флаг доставлен, эстафета окончена.
            distance_travelled = abs(delivery_time - start_time)
            total_distance += distance_travelled
            break
            
    # --- 4. Вывод результата ---
    
    # Ответ должен быть целым числом, округляем.
    print(f"{round(total_distance)}")

if __name__ == "__main__":
    solve()
